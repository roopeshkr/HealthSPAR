2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 22:58:27 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 22:58:27 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 22:58:27 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:58:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 22:58:27 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 22:58:27 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 22:58:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:58:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:58:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 22:58:57 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 22:58:57 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:58:57 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:58:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 22:58:57 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 22:58:57 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 22:58:57 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:58:57 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:58:57 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 22:59:27 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 22:59:27 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:59:27 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:59:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 22:59:27 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 22:59:27 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 22:59:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:59:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:59:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 22:59:57 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 22:59:57 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:59:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 22:59:57 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:59:57 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 22:59:57 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 22:59:57 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 22:59:57 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 22:59:57 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:00:27 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:00:27 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:00:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:00:27 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:00:27 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:00:27 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:00:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:00:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:00:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:00:45 [AsyncResolver-bootstrap-executor-0] INFO  c.n.d.s.r.aws.ConfigClusterResolver - Resolving eureka endpoints via configuration
2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:00:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:00:57 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:00:57 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:00:57 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:00:57 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:00:57 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:00:57 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:00:57 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:00:57 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:01:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:01:27 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:01:27 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:01:27 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:01:27 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:01:27 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:01:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:01:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:01:27 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:01:57 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:01:57 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:01:57 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:01:57 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:01:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:01:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:01:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:01:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:01:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:02:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:02:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:02:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:02:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:02:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:02:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:02:27 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:02:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:02:28 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:02:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:02:28 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:02:28 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:02:28 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:02:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:02:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:02:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:02:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:02:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:02:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:02:58 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:02:58 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:02:58 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:02:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:02:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:02:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:02:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:02:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:03:28 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:03:28 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:03:28 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:03:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:03:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:03:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:03:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:03:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:03:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:03:58 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:03:58 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:03:58 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:03:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:03:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:03:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:03:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:03:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:03:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:04:28 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:04:28 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:04:28 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:04:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:04:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:04:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:04:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:04:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:04:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:04:58 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:04:58 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:04:58 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:04:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:04:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:04:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:04:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:04:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:04:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:05:28 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:05:28 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:05:28 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:05:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:05:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:05:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:05:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:05:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-10] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:05:35 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:05:35 [http-nio-8070-exec-2] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:45 [AsyncResolver-bootstrap-executor-0] INFO  c.n.d.s.r.aws.ConfigClusterResolver - Resolving eureka endpoints via configuration
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-5] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:05:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:05:57 [http-nio-8070-exec-4] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:05:58 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:05:58 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:05:58 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:05:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:05:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:05:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:05:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:05:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:05:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:06:28 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:06:28 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:06:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:06:28 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:06:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:06:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:06:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:06:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:06:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:06:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:06:58 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:06:58 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:06:58 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:06:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:06:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:06:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:06:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:06:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:07:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:07:28 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:07:28 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:07:28 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:07:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:07:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:07:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:07:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:07:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:07:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:07:52 [http-nio-8070-exec-10] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-2] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:07:54 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:07:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:07:55 [http-nio-8070-exec-9] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:07:56 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:07:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:07:58 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:07:58 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:07:58 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:07:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:07:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:07:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:07:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:07:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:08:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:08:28 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:08:28 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:08:28 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:08:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:08:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:08:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:08:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:08:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:08:33 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:08:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Hospital`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (hospital:`Hospital`) SET hospital = $__properties__ RETURN hospital UNION MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ SET hospital += $__properties__ RETURN hospital
	                                                                                                                                                                                                       ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Hospital`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (hospital:`Hospital`) SET hospital = $__properties__ RETURN hospital UNION MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ SET hospital += $__properties__ RETURN hospital
	                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`FREQUENTLY_ASKED_QUESTION`]->(:`AskedQuestion`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`FREQUENTLY_ASKED_QUESTION`]->(:`AskedQuestion`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`AskedQuestion`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (askedQuestion:`AskedQuestion`) SET askedQuestion = $__properties__ RETURN askedQuestion UNION MATCH (askedQuestion:`AskedQuestion`) WHERE id(askedQuestion) = $__id__ SET askedQuestion += $__properties__ RETURN askedQuestion
	                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`AskedQuestion`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (askedQuestion:`AskedQuestion`) SET askedQuestion = $__properties__ RETURN askedQuestion UNION MATCH (askedQuestion:`AskedQuestion`) WHERE id(askedQuestion) = $__id__ SET askedQuestion += $__properties__ RETURN askedQuestion
	                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`FREQUENTLY_ASKED_QUESTION`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`FREQUENTLY_ASKED_QUESTION`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                    ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`FREQUENTLY_ASKED_QUESTION`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`LOCATED_IN`]->(:`City`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:08:52 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`LOCATED_IN`]->(:`City`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                       ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`City`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (city:`City`) SET city = $__properties__ RETURN city UNION MATCH (city:`City`) WHERE id(city) = $__id__ SET city += $__properties__ RETURN city
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`City`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (city:`City`) SET city = $__properties__ RETURN city UNION MATCH (city:`City`) WHERE id(city) = $__id__ SET city += $__properties__ RETURN city
	                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`LOCATED_IN`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                    ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`LOCATED_IN`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                                                                                                                                   ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`LOCATED_IN`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`HAS_DOCTOR`]->(:`Doctor`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`HAS_DOCTOR`]->(:`Doctor`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                                                                   ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Doctor`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (doctor:`Doctor`) SET doctor = $__properties__ RETURN doctor UNION MATCH (doctor:`Doctor`) WHERE id(doctor) = $__id__ SET doctor += $__properties__ RETURN doctor
	                                    ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Doctor`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (doctor:`Doctor`) SET doctor = $__properties__ RETURN doctor UNION MATCH (doctor:`Doctor`) WHERE id(doctor) = $__id__ SET doctor += $__properties__ RETURN doctor
	                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Doctor`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (doctor:`Doctor`) SET doctor = $__properties__ RETURN doctor UNION MATCH (doctor:`Doctor`) WHERE id(doctor) = $__id__ SET doctor += $__properties__ RETURN doctor
	                                    ^
The query used a deprecated function: `id`.
2023-10-05 23:08:53 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Doctor`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (doctor:`Doctor`) SET doctor = $__properties__ RETURN doctor UNION MATCH (doctor:`Doctor`) WHERE id(doctor) = $__id__ SET doctor += $__properties__ RETURN doctor
	                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`HAS_DOCTOR`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                    ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`HAS_DOCTOR`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                                                                                                                                   ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`HAS_DOCTOR`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:08:54 [http-nio-8070-exec-2] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:08:55 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:08:55 [http-nio-8070-exec-8] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:08:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:08:58 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:08:58 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:08:58 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:08:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:08:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:08:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:08:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:08:58 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:09:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:09:28 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:09:28 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:09:28 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:09:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:09:28 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:09:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:09:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:09:28 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:09:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:09:58 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:09:58 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:09:58 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:09:58 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:09:58 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:09:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:09:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:09:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:09:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:09:59 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:09:59 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:09:59 [http-nio-8070-exec-3] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:10:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:10:28 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:10:28 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:10:28 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:10:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:10:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:10:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:10:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:10:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:10:45 [AsyncResolver-bootstrap-executor-0] INFO  c.n.d.s.r.aws.ConfigClusterResolver - Resolving eureka endpoints via configuration
2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:10:58 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:10:58 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:10:58 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:10:58 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:10:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:10:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:10:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:10:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:10:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:11:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:11:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:11:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:11:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:11:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:11:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:11:28 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:11:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:11:29 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:11:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:11:29 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:11:29 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:11:29 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:11:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:11:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:11:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:11:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:11:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:11:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:11:59 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:11:59 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:11:59 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:11:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:11:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:11:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:11:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:11:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:12:29 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:12:29 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:12:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:12:29 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:12:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:12:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:12:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:12:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:12:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:12:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:12:59 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:12:59 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:12:59 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:12:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:12:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:12:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:12:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:12:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:13:29 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:13:29 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:13:29 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:13:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:13:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:13:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:13:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:13:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:13:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:13:59 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:13:59 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:13:59 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:13:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:13:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:13:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:13:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:13:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:13:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:14:29 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:14:29 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:14:29 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:14:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:14:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:14:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:14:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:14:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:14:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:14:59 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:14:59 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:14:59 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:14:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:14:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:14:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:14:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:14:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:14:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:15:29 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:15:29 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:15:29 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:15:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:15:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:15:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:15:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:15:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:15:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:15:45 [AsyncResolver-bootstrap-executor-0] INFO  c.n.d.s.r.aws.ConfigClusterResolver - Resolving eureka endpoints via configuration
2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:15:59 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:15:59 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:15:59 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:15:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:15:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:15:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:15:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:15:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:15:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:16:29 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:16:29 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:16:29 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:16:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:16:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:16:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:16:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:16:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:16:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:16:59 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:16:59 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:16:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:16:59 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:16:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:16:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:16:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:16:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:16:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:17:29 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:17:29 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:17:29 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:17:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:17:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:17:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:17:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:17:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:17:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:17:59 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:17:59 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:17:59 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:17:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:17:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:17:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:17:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:17:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:17:59 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:18:29 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:18:29 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:18:29 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:18:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:18:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:18:29 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:18:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:18:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:18:29 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:18:59 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:18:59 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:18:59 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:18:59 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:18:59 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:19:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:19:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:19:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:19:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:19:29 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:19:29 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:19:29 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:19:29 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:19:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:19:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:19:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:19:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:19:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:19:48 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:19:49 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:19:49 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:19:49 [http-nio-8070-exec-1] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:20:00 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:20:00 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:20:00 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:20:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:20:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:20:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:20:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:20:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:20:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:20:27 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:20:27 [http-nio-8070-exec-10] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:20:30 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:20:30 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:20:30 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:20:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:20:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:20:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:20:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:20:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:20:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:20:45 [AsyncResolver-bootstrap-executor-0] INFO  c.n.d.s.r.aws.ConfigClusterResolver - Resolving eureka endpoints via configuration
2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:21:00 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:21:00 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:21:00 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:21:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:21:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:21:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:21:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:21:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:21:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:21:30 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:21:30 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:21:30 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:21:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:21:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:21:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:21:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:21:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:21:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:21:32 [http-nio-8070-exec-9] WARN  o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver - Resolved [com.stackroute.exception.HospitalNotFoundException: Hospital not found with id : 40]
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:21:34 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:21:34 [http-nio-8070-exec-3] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:21:38 [http-nio-8070-exec-4] WARN  o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver - Resolved [org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; For input string: "NaN"]
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:21:40 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:21:40 [http-nio-8070-exec-1] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Hospital`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (hospital:`Hospital`) SET hospital = $__properties__ RETURN hospital UNION MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ SET hospital += $__properties__ RETURN hospital
	                                                                                                                                                                                                       ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Hospital`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (hospital:`Hospital`) SET hospital = $__properties__ RETURN hospital UNION MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ SET hospital += $__properties__ RETURN hospital
	                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`FREQUENTLY_ASKED_QUESTION`]->(:`AskedQuestion`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:21:44 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`FREQUENTLY_ASKED_QUESTION`]->(:`AskedQuestion`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`AskedQuestion`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (askedQuestion:`AskedQuestion`) SET askedQuestion = $__properties__ RETURN askedQuestion UNION MATCH (askedQuestion:`AskedQuestion`) WHERE id(askedQuestion) = $__id__ SET askedQuestion += $__properties__ RETURN askedQuestion
	                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`AskedQuestion`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (askedQuestion:`AskedQuestion`) SET askedQuestion = $__properties__ RETURN askedQuestion UNION MATCH (askedQuestion:`AskedQuestion`) WHERE id(askedQuestion) = $__id__ SET askedQuestion += $__properties__ RETURN askedQuestion
	                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`FREQUENTLY_ASKED_QUESTION`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`FREQUENTLY_ASKED_QUESTION`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                    ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`FREQUENTLY_ASKED_QUESTION`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`LOCATED_IN`]->(:`City`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`LOCATED_IN`]->(:`City`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                       ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`City`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (city:`City`) SET city = $__properties__ RETURN city UNION MATCH (city:`City`) WHERE id(city) = $__id__ SET city += $__properties__ RETURN city
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`City`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (city:`City`) SET city = $__properties__ RETURN city UNION MATCH (city:`City`) WHERE id(city) = $__id__ SET city += $__properties__ RETURN city
	                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`LOCATED_IN`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                    ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`LOCATED_IN`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                                                                                                                                   ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`LOCATED_IN`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`HAS_DOCTOR`]->(:`Doctor`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (startNode)-[rel:`HAS_DOCTOR`]->(:`Doctor`) WHERE (id(startNode) = $fromId AND NOT (toString(id(rel)) IN $__knownRelationShipIds__)) DELETE rel
	                                                                                                   ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Doctor`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (doctor:`Doctor`) SET doctor = $__properties__ RETURN doctor UNION MATCH (doctor:`Doctor`) WHERE id(doctor) = $__id__ SET doctor += $__properties__ RETURN doctor
	                                    ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	OPTIONAL MATCH (hlp:`Doctor`) WHERE id(hlp) = $__id__ WITH hlp WHERE hlp IS NULL CREATE (doctor:`Doctor`) SET doctor = $__properties__ RETURN doctor UNION MATCH (doctor:`Doctor`) WHERE id(doctor) = $__id__ SET doctor += $__properties__ RETURN doctor
	                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`HAS_DOCTOR`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                    ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`HAS_DOCTOR`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                                                                                                                                   ^
The query used a deprecated function: `id`.
2023-10-05 23:21:45 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	UNWIND $__relationships__ AS relationship WITH relationship MATCH (startNode) WHERE id(startNode) = relationship.fromId MATCH (endNode) WHERE id(endNode) = relationship.toId MERGE (startNode)-[relProps:`HAS_DOCTOR`]->(endNode) RETURN toString(id(relProps)) AS __elementId__
	                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:22:00 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:22:00 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:22:00 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:22:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:22:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:22:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:22:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:22:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:22:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:22:30 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:22:30 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:22:30 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:22:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:22:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:22:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:22:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:22:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:22:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:22:58 [http-nio-8070-exec-10] WARN  o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver - Resolved [com.stackroute.exception.HospitalNotFoundException: Hospital not found with id : 40]
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:22:59 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:22:59 [http-nio-8070-exec-9] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:00 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:23:00 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:23:00 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:23:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:23:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:23:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:23:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:23:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:03 [http-nio-8070-exec-5] WARN  o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver - Resolved [org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; For input string: "NaN"]
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:05 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:23:05 [http-nio-8070-exec-4] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:30 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:23:30 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:23:30 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:23:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:23:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:23:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:23:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:23:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-1] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:51 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:23:51 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:23:52 [http-nio-8070-exec-7] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:53 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:23:53 [http-nio-8070-exec-10] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-9] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:55 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:23:55 [http-nio-8070-exec-5] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-4] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:57 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:23:57 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:23:58 [http-nio-8070-exec-1] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:58 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:23:59 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:24:00 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:24:00 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:24:00 [http-nio-8070-exec-2] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:00 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:24:00 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:24:00 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:24:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:24:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:24:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:24:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:24:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-9] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:24:01 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:24:02 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:24:02 [http-nio-8070-exec-8] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-4] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:24:03 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:24:04 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:24:04 [http-nio-8070-exec-3] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:24:13 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:24:13 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:24:30 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:24:30 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:24:30 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:24:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:24:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:24:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:24:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:24:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:24:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:25:00 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:25:00 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:25:00 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:25:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:25:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:25:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:25:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:25:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:25:30 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:25:30 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:25:30 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:25:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:25:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:25:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:25:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:25:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:25:38 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:25:38 [http-nio-8070-exec-10] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-4] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:25:40 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:25:41 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:25:41 [http-nio-8070-exec-5] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:25:45 [AsyncResolver-bootstrap-executor-0] INFO  c.n.d.s.r.aws.ConfigClusterResolver - Resolving eureka endpoints via configuration
2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:26:00 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:26:00 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:26:00 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:26:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:26:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:26:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:26:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:26:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:26:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:26:30 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:26:30 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:26:30 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:26:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:26:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:26:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:26:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:26:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:26:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:27:00 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:27:00 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:27:00 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:27:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:27:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:27:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:27:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:27:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:27:00 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:27:30 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:27:30 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:27:30 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:27:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:27:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:27:30 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:27:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:27:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:27:30 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:28:00 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:28:00 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:28:00 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:28:00 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:28:00 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:28:01 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:28:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:28:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:28:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:28:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:28:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:28:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:28:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:28:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:28:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:28:30 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:28:30 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:28:30 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:28:30 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:28:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:28:31 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:28:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:28:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:28:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:28:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:28:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:28:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:29:01 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:29:01 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:29:01 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:29:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:29:01 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:29:01 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:29:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:29:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:29:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:29:31 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:29:31 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:29:31 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:29:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:29:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:29:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:29:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:29:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:29:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:30:01 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:30:01 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:30:01 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:30:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:30:01 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:30:01 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:30:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:30:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:30:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:30:31 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:30:31 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:30:31 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:30:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:30:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:30:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:30:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:30:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:30:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:30:45 [AsyncResolver-bootstrap-executor-0] INFO  c.n.d.s.r.aws.ConfigClusterResolver - Resolving eureka endpoints via configuration
2023-10-05 23:31:01 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:31:01 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:31:01 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:31:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:31:01 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:31:01 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:31:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:31:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:31:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:31:31 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:31:31 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:31:31 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:31:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:31:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:31:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:31:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:31:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:31:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:32:01 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:32:01 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:32:01 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:32:01 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:32:01 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:32:01 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:32:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:32:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:01 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:32:14 [http-nio-8070-exec-1] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:32:19 [http-nio-8070-exec-6] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:32:20 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                                                              ^
The query used a deprecated function: `id`.
2023-10-05 23:32:20 [http-nio-8070-exec-7] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (doctor:`Doctor`) WHERE doctor.fileName = $fileName RETURN doctor{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(doctor), __internalNeo4jId__: id(doctor), __elementId__: toString(id(doctor))}
	                                                                                                                                                                                                                                                                          ^
The query used a deprecated function: `id`.
2023-10-05 23:32:20 [http-nio-8070-exec-7] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.DoctorImageController.getDoctorImage(DoctorImageController.java:75)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:32:23 [http-nio-8070-exec-2] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-10] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-10] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:32:29 [http-nio-8070-exec-9] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-4] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:32:29 [http-nio-8070-exec-4] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Disable delta property : false
2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Single vip registry refresh property : null
2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Force full registry fetch : false
2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application is null : false
2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Registered Applications size is zero : true
2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Application version is -1: true
2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - Getting all instance registry info from the eureka server
2023-10-05 23:32:31 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:32:31 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:32:31 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplicationsInternal(RestTemplateEurekaHttpClient.java:149)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.getApplications(RestTemplateEurekaHttpClient.java:139)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 23 more

2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on GET request for "http://localhost:8076/eureka/apps/": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:32:31 [DiscoveryClient-CacheRefreshExecutor-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to refresh its cache! This periodic background refresh will be retried in 30 seconds. status = Cannot execute request on any known server stacktrace = com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$6.execute(EurekaHttpClientDecorator.java:137)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.getApplications(EurekaHttpClientDecorator.java:134)
	at com.netflix.discovery.DiscoveryClient.getAndStoreFullRegistry(DiscoveryClient.java:1045)
	at com.netflix.discovery.DiscoveryClient.fetchRegistry(DiscoveryClient.java:958)
	at com.netflix.discovery.DiscoveryClient.refreshRegistry(DiscoveryClient.java:1475)
	at com.netflix.discovery.DiscoveryClient$CacheRefreshThread.run(DiscoveryClient.java:1442)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)

2023-10-05 23:32:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070: registering service...
2023-10-05 23:32:31 [DiscoveryClient-InstanceInfoReplicator-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.register(RestTemplateEurekaHttpClient.java:81)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 21 more

2023-10-05 23:32:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on POST request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:32:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - registration failed Cannot execute request on any known server
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:31 [DiscoveryClient-InstanceInfoReplicator-0] WARN  c.n.discovery.InstanceInfoReplicator - There was a problem with the instance info replicator
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)
	at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:820)
	at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-5] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-5] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                         ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                               ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                          ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:32:32 [http-nio-8070-exec-8] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE id(hospital) = $__id__ RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                     ^
The query used a deprecated function: `id`.
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalRating)
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ^
The query used a deprecated function: `id`.
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                      ^
The query used a deprecated function: `id`.
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.UnknownPropertyKeyWarning: The provided property key is not in the database
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                 ^
One of the property names in your query is not available in the database, make sure you didn't misspell it or that the label is available when you run this statement in your application (the missing property name is: hospitalReviews)
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ^
The query used a deprecated function: `id`.
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ^
The query used a deprecated function: `id`.
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ^
The query used a deprecated function: `id`.
2023-10-05 23:32:33 [http-nio-8070-exec-3] WARN  o.springframework.data.neo4j.cypher - Neo.ClientNotification.Statement.FeatureDeprecationWarning: This feature is deprecated and will be removed in future versions.
	MATCH (hospital:`Hospital`) WHERE hospital.fileName = $fileName RETURN hospital{.fileName, .fileType, .hospitalAmenities, .hospitalEmail, .hospitalName, .hospitalPhoneNumber, .hospitalRating, .hospitalReviews, .hospitalWebsite, .imageData, .numberOfBeds, __nodeLabels__: labels(hospital), __internalNeo4jId__: id(hospital), __elementId__: toString(id(hospital)), Hospital_FREQUENTLY_ASKED_QUESTION_AskedQuestion: [(hospital)-[:`FREQUENTLY_ASKED_QUESTION`]->(hospital_frequentlyAskedQuestion:`AskedQuestion`) | hospital_frequentlyAskedQuestion{.answer, .question, __nodeLabels__: labels(hospital_frequentlyAskedQuestion), __internalNeo4jId__: id(hospital_frequentlyAskedQuestion), __elementId__: toString(id(hospital_frequentlyAskedQuestion))}], Hospital_LOCATED_IN_City: [(hospital)-[:`LOCATED_IN`]->(hospital_city:`City`) | hospital_city{.country, .district, .name, .state, .zip, __nodeLabels__: labels(hospital_city), __internalNeo4jId__: id(hospital_city), __elementId__: toString(id(hospital_city))}], Hospital_HAS_DOCTOR_Doctor: [(hospital)-[:`HAS_DOCTOR`]->(hospital_doctors:`Doctor`) | hospital_doctors{.bio, .department, .doctorName, .endTime, .fileName, .fileType, .imageData, .languagesSpoken, .qualification, .startTime, .yearOfExperience, __nodeLabels__: labels(hospital_doctors), __internalNeo4jId__: id(hospital_doctors), __elementId__: toString(id(hospital_doctors))}]}
	                                                                                                                                                                                                                                                                                                                                                            ^
The query used a deprecated function: `id`.
2023-10-05 23:32:33 [http-nio-8070-exec-3] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.util.NoSuchElementException: No value present] with root cause
java.util.NoSuchElementException: No value present
	at java.base/java.util.Optional.get(Optional.java:143)
	at com.stackroute.controller.HospitalImageController.getImage(HospitalImageController.java:66)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104)
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:884)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1081)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:527)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:614)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:482)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:391)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1740)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.base/java.lang.Thread.run(Thread.java:1589)
2023-10-05 23:33:01 [DiscoveryClient-HeartbeatExecutor-0] INFO  c.n.d.s.t.d.RedirectingEurekaHttpClient - Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8076/eureka/}, exception=I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information stacktrace=org.springframework.web.client.ResourceAccessException: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at org.springframework.web.client.RestTemplate.createResourceAccessException(RestTemplate.java:888)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:868)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:764)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:646)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.sendHeartBeat(RestTemplateEurekaHttpClient.java:103)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
Caused by: org.apache.hc.client5.http.HttpHostConnectException: Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
	at java.base/sun.nio.ch.Net.pollConnect(Native Method)
	at java.base/sun.nio.ch.Net.pollConnectNow(Net.java:672)
	at java.base/sun.nio.ch.NioSocketImpl.timedFinishConnect(NioSocketImpl.java:535)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:585)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:666)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.lambda$connectSocket$0(PlainConnectionSocketFactory.java:85)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.apache.hc.client5.http.socket.PlainConnectionSocketFactory.connectSocket(PlainConnectionSocketFactory.java:84)
	at org.apache.hc.client5.http.socket.ConnectionSocketFactory.connectSocket(ConnectionSocketFactory.java:113)
	at org.apache.hc.client5.http.impl.io.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:181)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:447)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:162)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.connectEndpoint(InternalExecRuntime.java:172)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:142)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:106)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:93)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:101)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:87)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:71)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:862)
	... 20 more

2023-10-05 23:33:01 [DiscoveryClient-HeartbeatExecutor-0] WARN  c.n.d.s.t.d.RetryableEurekaHttpClient - Request execution failed with message: I/O error on PUT request for "http://localhost:8076/eureka/apps/RECOMMEND-SERVICE/localhost:recommend-service:8070": Connect to http://localhost:8076 [localhost/127.0.0.1, localhost/0:0:0:0:0:0:0:1] failed: Connection refused: no further information
2023-10-05 23:33:01 [DiscoveryClient-HeartbeatExecutor-0] ERROR c.netflix.discovery.DiscoveryClient - DiscoveryClient_RECOMMEND-SERVICE/localhost:recommend-service:8070 - was unable to send heartbeat!
com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$3.execute(EurekaHttpClientDecorator.java:92)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.sendHeartBeat(EurekaHttpClientDecorator.java:89)
	at com.netflix.discovery.DiscoveryClient.renew(DiscoveryClient.java:837)
	at com.netflix.discovery.DiscoveryClient$HeartbeatThread.run(DiscoveryClient.java:1401)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:577)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1589)
